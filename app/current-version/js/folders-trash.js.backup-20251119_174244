/**
 * Folders & Trash Management - IndexedDB Version
 * Handles folder creation, organization, and trash bin functionality
 */

// Current folder path (for navigation)
let currentFolderPath = [];
let selectedFolderColor = 'purple'; // Default color
let currentPageType = 'designs'; // Track which page we're on: 'designs' or 'templates'
let navigationHistory = { page: 'landing', folderPath: [] }; // Track where we came from for back button

// Track clicked items and edit state
let selectedItems = new Set();
let isEditingFilename = false;

// ============================================
// INDEXEDDB HELPER FUNCTIONS (FOLDERS)
// ============================================

async function saveFolderToDB(folderId, folderData) {
    await EmailBriefingDB.saveFolder(folderId, folderData);
}

async function getFolderFromDB(folderId) {
    const folder = await EmailBriefingDB.getFolder(folderId);
    return folder;
}

async function getAllFoldersFromDB() {
    return await EmailBriefingDB.getAllFolders();
}

async function deleteFolderFromDB(folderId) {
    await EmailBriefingDB.deleteFolder(folderId);
}

// ============================================
// BREADCRUMB NAVIGATION
// ============================================

function updateBreadcrumb() {
    const templatesTitle = document.querySelector('#masthead-subnav-templates .masthead-subnav-title');
    const myDesignsTitle = document.querySelector('#masthead-subnav-mydesigns .masthead-subnav-title');
    
    // Determine which page is active
    const templatesScreen = document.getElementById('template-selection-screen');
    const myDesignsScreen = document.getElementById('my-designs-screen');
    
    let isTemplatesActive = templatesScreen && templatesScreen.classList.contains('active');
    let isDesignsActive = myDesignsScreen && myDesignsScreen.classList.contains('active');
    
    if (isTemplatesActive && templatesTitle) {
        renderBreadcrumbForElement(templatesTitle, 'Templates');
    } else if (isDesignsActive && myDesignsTitle) {
        renderBreadcrumbForElement(myDesignsTitle, 'My Designs');
    }
}

function renderBreadcrumbForElement(element, rootName) {
    // Clear existing content
    element.innerHTML = '';
    
    // Create root breadcrumb segment
    const rootSegment = document.createElement('span');
    rootSegment.className = 'breadcrumb-segment';
    rootSegment.textContent = rootName;
    rootSegment.onclick = () => navigateToFolder(-1);
    
    // Make root segment a drop target
    makeBreadcrumbDropTarget(rootSegment, null);
    
    element.appendChild(rootSegment);
    
    // Add folder segments
    currentFolderPath.forEach((folder, index) => {
        // Add separator
        const separator = document.createElement('span');
        separator.className = 'breadcrumb-separator';
        separator.textContent = '>';
        element.appendChild(separator);
        
        // Add folder segment
        const folderSegment = document.createElement('span');
        folderSegment.className = 'breadcrumb-segment';
        folderSegment.textContent = folder.name;
        folderSegment.onclick = () => navigateToFolder(index);
        
        // Make folder segment a drop target
        makeBreadcrumbDropTarget(folderSegment, folder.id);
        
        element.appendChild(folderSegment);
    });
}

function makeBreadcrumbDropTarget(element, targetFolderId) {
    element.addEventListener('dragover', function(e) {
        e.preventDefault();
        this.classList.add('drag-over');
    });
    
    element.addEventListener('dragleave', function(e) {
        this.classList.remove('drag-over');
    });
    
    element.addEventListener('drop', async function(e) {
        e.preventDefault();
        e.stopPropagation();
        this.classList.remove('drag-over');
        
        const itemKey = e.dataTransfer.getData('text/plain');
        if (!itemKey) return;
        
        // Don't allow dropping a folder into itself
        if (itemKey === targetFolderId) return;
        
        // Remove from current location
        const currentFolderId = getCurrentFolderId();
        if (currentFolderId) {
            await removeItemFromFolder(currentFolderId, itemKey);
        }
        
        // Remove from all folders
        const allFolders = await getAllFoldersFromDB();
        for (const folder of allFolders) {
            if (folder.items && folder.items.includes(itemKey)) {
                await removeItemFromFolder(folder.id, itemKey);
            }
        }
        
        // Add to target folder (if not root)
        if (targetFolderId) {
            await addItemToFolder(targetFolderId, itemKey);
        }
        
        // Refresh appropriate view
        const templatesScreen = document.getElementById('template-selection-screen');
        if (templatesScreen && templatesScreen.classList.contains('active')) {
            await loadTemplateCards();
        } else {
            await loadSavedDesigns();
        }
    });
}

// ============================================
// FOLDER MANAGEMENT
// ============================================

function createNewFolder() {
    // Determine which page we're on
    const templatesScreen = document.getElementById('template-selection-screen');
    const myDesignsScreen = document.getElementById('my-designs-screen');
    
    if (templatesScreen && templatesScreen.classList.contains('active')) {
        currentPageType = 'templates';
    } else if (myDesignsScreen && myDesignsScreen.classList.contains('active')) {
        currentPageType = 'designs';
    }
    
    // Reset selection to default
    selectedFolderColor = 'purple';
    
    // Clear input
    const folderNameInput = document.getElementById('folder-name-input');
    if (folderNameInput) {
        folderNameInput.value = '';
    }
    
    // Clear previous selection
    document.querySelectorAll('.color-option').forEach(option => {
        option.classList.remove('selected');
    });
    document.querySelector('.color-option[data-color="purple"]')?.classList.add('selected');
    
    // Open modal
    const modal = document.getElementById('folder-color-modal');
    if (modal) {
        modal.classList.add('active');
        folderNameInput?.focus();
    }
}

function selectFolderColor(color) {
    selectedFolderColor = color;
    
    // Update selected state visually
    document.querySelectorAll('.color-option').forEach(option => {
        option.classList.remove('selected');
    });
    document.querySelector(`.color-option[data-color="${color}"]`)?.classList.add('selected');
}

async function saveFolderFromModal() {
    const folderNameInput = document.getElementById('folder-name-input');
    const folderName = folderNameInput?.value.trim();
    
    if (!folderName) {
        alert('Please enter a folder name');
        return;
    }
    
    const folderId = 'email-folder-' + Date.now();
    const folder = {
        name: folderName,
        color: selectedFolderColor,
        pageType: currentPageType,
        parentPath: [...currentFolderPath],
        createdDate: new Date().toISOString(),
        items: []
    };
    
    // Save to IndexedDB
    await saveFolderToDB(folderId, folder);
    
    // Add folder to current folder if we're inside one
    const currentFolderId = getCurrentFolderId();
    if (currentFolderId) {
        await addItemToFolder(currentFolderId, folderId);
    }
    
    closeFolderColorModal();
    
    // Refresh the appropriate view
    if (currentPageType === 'templates') {
        await loadTemplateCards();
    } else {
        await loadSavedDesigns();
    }
}

function closeFolderColorModal() {
    const modal = document.getElementById('folder-color-modal');
    if (modal) {
        modal.classList.remove('active');
    }
}

function setupNewFolderButton() {
    const btn = document.getElementById('new-folder-btn');
    const btnTemplates = document.getElementById('new-folder-btn-templates');
    
    if (btn) {
        btn.addEventListener('click', createNewFolder);
    }
    if (btnTemplates) {
        btnTemplates.addEventListener('click', createNewFolder);
    }
}

async function openFolder(folderId) {
    const folder = await getFolderFromDB(folderId);
    if (!folder) return;
    
    // Save navigation state before entering folder
    const templatesScreen = document.getElementById('template-selection-screen');
    if (templatesScreen && templatesScreen.classList.contains('active')) {
        navigationHistory = {
            page: 'template-selection',
            folderPath: [...currentFolderPath]
        };
    } else {
        navigationHistory = {
            page: 'my-designs',
            folderPath: [...currentFolderPath]
        };
    }
    
    currentFolderPath.push({
        id: folderId,
        name: folder.name
    });
    
    // Refresh the appropriate view based on folder type
    if (folder.pageType === 'templates') {
        await loadTemplateCards();
    } else {
        await loadSavedDesigns();
    }
    
    updateBreadcrumb();
}

async function navigateToFolder(folderIndex) {
    if (folderIndex === -1) {
        // Navigate to root
        currentFolderPath = [];
    } else {
        // Navigate to specific folder in path
        currentFolderPath = currentFolderPath.slice(0, folderIndex + 1);
    }
    
    // Update navigation history
    const templatesScreen = document.getElementById('template-selection-screen');
    if (templatesScreen && templatesScreen.classList.contains('active')) {
        navigationHistory = {
            page: 'template-selection',
            folderPath: [...currentFolderPath]
        };
    } else {
        navigationHistory = {
            page: 'my-designs',
            folderPath: [...currentFolderPath]
        };
    }
    
    // Determine which view to refresh
    if (templatesScreen && templatesScreen.classList.contains('active')) {
        await loadTemplateCards();
    } else {
        await loadSavedDesigns();
    }
    
    updateBreadcrumb();
}

function getCurrentFolderId() {
    if (currentFolderPath.length === 0) return null;
    const lastFolder = currentFolderPath[currentFolderPath.length - 1];
    return lastFolder.id;
}

async function addItemToFolder(folderId, itemKey) {
    const folder = await getFolderFromDB(folderId);
    if (!folder) return;
    
    if (!folder.items.includes(itemKey)) {
        folder.items.push(itemKey);
        await saveFolderToDB(folderId, folder);
    }
}

async function removeItemFromFolder(folderId, itemKey) {
    const folder = await getFolderFromDB(folderId);
    if (!folder) return;
    
    folder.items = folder.items.filter(item => item !== itemKey);
    await saveFolderToDB(folderId, folder);
}

async function deleteFolder(folderId) {
    if (!confirm('Delete this folder and all its contents?')) return;
    
    const folder = await getFolderFromDB(folderId);
    if (!folder) return;
    
    // Move all items to trash
    for (const itemKey of folder.items) {
        await moveToTrash(itemKey);
    }
    
    // Move folder itself to trash
    await EmailBriefingDB.saveMeta('trashed-folder-' + Date.now(), folder);
    await deleteFolderFromDB(folderId);
    
    // If we're inside this folder, go back to root
    if (getCurrentFolderId() === folderId) {
        currentFolderPath = [];
    }
    
    // Refresh appropriate view
    if (folder.pageType === 'templates') {
        await loadTemplateCards();
    } else {
        await loadSavedDesigns();
    }
    updateTrashCount();
    updateBreadcrumb();
}

async function renameFolder(folderId) {
    const folder = await getFolderFromDB(folderId);
    if (!folder) return;
    
    const newName = prompt('Enter new folder name:', folder.name);
    if (!newName || newName.trim() === '') return;
    
    folder.name = newName.trim();
    await saveFolderToDB(folderId, folder);
    
    // Update current path if this folder is in it
    currentFolderPath = currentFolderPath.map(item => {
        if (item.id === folderId) {
            return { ...item, name: newName.trim() };
        }
        return item;
    });
    
    // Refresh appropriate view
    if (folder.pageType === 'templates') {
        await loadTemplateCards();
    } else {
        await loadSavedDesigns();
    }
    
    updateBreadcrumb();
}

// Handle icon clicks for selection and rename
function handleIconClick(event, card, itemKey, itemName, itemType) {
    event.stopPropagation();
    
    const titleElement = card.querySelector('.design-card-title, .folder-card-title');
    
    // Clear other selections
    document.querySelectorAll('.design-card.selected, .folder-card.selected').forEach(c => {
        if (c !== card) c.classList.remove('selected');
    });
    selectedItems.clear();
    
    // Select this item
    card.classList.add('selected');
    selectedItems.add(itemKey);
    
    // Make title editable on second click (if already selected)
    if (titleElement && !isEditingFilename) {
        const wasSelected = card.classList.contains('was-selected');
        
        if (wasSelected) {
            // Second click - enable editing
            isEditingFilename = true;
            const originalText = titleElement.textContent;
            
            titleElement.contentEditable = true;
            titleElement.classList.add('editing');
            
            // Select all text
            const range = document.createRange();
            range.selectNodeContents(titleElement);
            const sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(range);
            
            // Handle save on blur or enter
            async function saveEdit() {
                if (!isEditingFilename) return;
                
                const newName = titleElement.textContent.trim();
                titleElement.contentEditable = false;
                titleElement.classList.remove('editing');
                isEditingFilename = false;
                
                if (newName && newName !== originalText) {
                    // Save the new name
                    if (itemType === 'folder') {
                        const folder = await getFolderFromDB(itemKey);
                        if (folder) {
                            folder.name = newName;
                            await saveFolderToDB(itemKey, folder);
                            
                            // Update current path if needed
                            currentFolderPath = currentFolderPath.map(item => {
                                if (item.id === itemKey) {
                                    return { ...item, name: newName };
                                }
                                return item;
                            });
                            updateBreadcrumb();
                        }
                    } else {
                        // It's a design
                        const dataStr = await dbGet(itemKey);
                        if (dataStr) {
                            const design = JSON.parse(dataStr);
                            design.projectName = newName;
                            await dbSave(itemKey, JSON.stringify(design));
                        }
                    }
                } else {
                    titleElement.textContent = originalText;
                }
                
                card.classList.remove('was-selected');
            }
            
            titleElement.addEventListener('blur', saveEdit, { once: true });
            titleElement.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    titleElement.blur();
                }
                if (e.key === 'Escape') {
                    titleElement.textContent = originalText;
                    titleElement.blur();
                }
            });
        } else {
            // First click - mark as selected
            card.classList.add('was-selected');
            
            // Remove was-selected after a delay if no second click
            setTimeout(() => {
                card.classList.remove('was-selected');
            }, 1000);
        }
    }
}

// Handle double-click to open
function handleIconDoubleClick(event, itemKey, itemType) {
    event.stopPropagation();
    
    if (itemType === 'folder') {
        openFolder(itemKey);
    } else if (itemType === 'design') {
        loadDesignFromCard(itemKey);
    } else if (itemType === 'export') {
        downloadExportFile(itemKey);
    } else if (itemType === 'template') {
        const templateId = itemKey.replace('template-', '');
        selectTemplate(templateId);
    }
}

// ============================================
// TEMPLATE CARDS WITH FOLDERS
// ============================================

async function loadTemplateCards() {
    const grid = document.getElementById('template-cards-grid');
    if (!grid) return;
    
    const currentFolderId = getCurrentFolderId();
    
    // Clear grid
    grid.innerHTML = '';
    
    // 1. Get all user-created folders for templates
    const allFolders = await getAllFoldersFromDB();
    const templateFolders = allFolders.filter(f => f.pageType === 'templates');
    
    // 2. Determine which folders to show
    let visibleFolders = [];
    if (currentFolderId) {
        const currentFolder = await getFolderFromDB(currentFolderId);
        if (currentFolder) {
            visibleFolders = templateFolders.filter(f => currentFolder.items.includes(f.id));
        }
        
        // Also check parentPath
        const subFolders = templateFolders.filter(f => {
            const parentPath = f.parentPath || [];
            return parentPath.some(p => p.id === currentFolderId);
        });
        subFolders.forEach(f => {
            if (!visibleFolders.find(vf => vf.id === f.id)) {
                visibleFolders.push(f);
            }
        });
    } else {
        visibleFolders = templateFolders.filter(f => {
            return !f.parentPath || f.parentPath.length === 0;
        });
    }
    
    // 3. Render folders
    visibleFolders.forEach(folder => {
        const folderColor = folder.color || 'purple';
        const card = document.createElement('div');
        card.className = 'folder-card';
        card.innerHTML = `
            <div class="folder-card-content">
                <img src="assets/images/folder-${folderColor}.png" class="folder-icon" alt="Folder">
                <h3 class="folder-card-title">${folder.name}</h3>
            </div>
        `;
        
        card.addEventListener('click', function(e) {
            handleIconClick(e, card, folder.id, folder.name, 'folder');
        });
        
        card.addEventListener('dblclick', function(e) {
            handleIconDoubleClick(e, folder.id, 'folder');
        });
        
        card.addEventListener('contextmenu', function(e) {
            e.preventDefault();
            showFolderContextMenu(e, folder.id);
        });
        
        makeDraggable(card, folder.id);
        makeFolderDropTarget(card, folder.id);
        
        grid.appendChild(card);
    });
    
    // 4. Determine which templates to show
    const templatesInFolders = new Set();
    templateFolders.forEach(f => {
        f.items.forEach(item => {
            if (item.startsWith('template-')) {
                templatesInFolders.add(item);
            }
        });
    });
    
    let visibleTemplates = [];
    if (currentFolderId) {
        const currentFolder = await getFolderFromDB(currentFolderId);
        if (currentFolder) {
            currentFolder.items.forEach(itemKey => {
                if (itemKey.startsWith('template-')) {
                    const templateId = itemKey.replace('template-', '');
                    if (templates[templateId]) {
                        visibleTemplates.push(templateId);
                    }
                }
            });
        }
    } else {
        Object.keys(templates).forEach(templateId => {
            const templateKey = 'template-' + templateId;
            if (!templatesInFolders.has(templateKey)) {
                visibleTemplates.push(templateId);
            }
        });
    }
    
    // 5. Render template cards
    visibleTemplates.forEach(templateId => {
        const template = templates[templateId];
        const templateKey = 'template-' + templateId;
        
        const card = document.createElement('div');
        card.className = 'template-card design-card';
        card.innerHTML = `
            <div class="template-card-content design-card-content">
                <img src="assets/images/template-icon.png" alt="${template.name}" class="document-icon">
                <h3 class="template-card-title design-card-title">${template.name}</h3>
            </div>
        `;
        
        card.addEventListener('click', function(e) {
            handleIconClick(e, card, templateKey, template.name, 'template');
        });
        
        card.addEventListener('dblclick', function(e) {
            handleIconDoubleClick(e, templateKey, 'template');
        });
        
        makeDraggable(card, templateKey);
        
        grid.appendChild(card);
    });
    
    updateBreadcrumb();
}

// ============================================
// TRASH BIN FUNCTIONALITY
// ============================================

function setupTrashBin() {
    const trashBin = document.getElementById('trash-bin');
    const trashBinTemplates = document.getElementById('trash-bin-templates');
    
    [trashBin, trashBinTemplates].forEach(bin => {
        if (!bin) return;
        
        bin.addEventListener('dblclick', openTrashModal);
        
        bin.addEventListener('dragover', function(e) {
            e.preventDefault();
            this.classList.add('drag-over');
            this.style.transform = 'scale(1.15)';
        });
        
        bin.addEventListener('dragleave', function(e) {
            this.classList.remove('drag-over');
            this.style.transform = '';
        });
        
        bin.addEventListener('drop', async function(e) {
            e.preventDefault();
            this.classList.remove('drag-over');
            this.style.transform = '';
            
            const itemKey = e.dataTransfer.getData('text/plain');
            if (itemKey) {
                if (itemKey.startsWith('template-')) {
                    alert('System templates cannot be deleted. You can only move them into folders.');
                    return;
                }
                await moveToTrash(itemKey);
            }
        });
    });
    
    updateTrashCount();
}

async function moveToTrash(itemKey) {
    const dataStr = await dbGet(itemKey);
    if (!dataStr) return;
    
    // Remove from any folder
    const currentFolder = getCurrentFolderId();
    if (currentFolder) {
        await removeItemFromFolder(currentFolder, itemKey);
    }
    
    // Remove from all folders
    const allFolders = await getAllFoldersFromDB();
    for (const folder of allFolders) {
        if (folder.items && folder.items.includes(itemKey)) {
            await removeItemFromFolder(folder.id, itemKey);
        }
    }
    
    // Move to trash
    if (itemKey.startsWith('email-folder-')) {
        const folder = await getFolderFromDB(itemKey);
        await EmailBriefingDB.saveMeta('trashed-folder-' + Date.now(), folder);
        await deleteFolderFromDB(itemKey);
    } else {
        await EmailBriefingDB.saveMeta('trashed-' + itemKey, dataStr);
        await dbDelete(itemKey);
    }
    
    // Refresh appropriate view
    const templatesScreen = document.getElementById('template-selection-screen');
    if (templatesScreen && templatesScreen.classList.contains('active')) {
        await loadTemplateCards();
    } else {
        await loadSavedDesigns();
    }
    updateTrashCount();
}

async function updateTrashCount() {
    // Implementation simplified - count trash items from metadata
    // You can implement full trash counting later if needed
    const countBadges = document.querySelectorAll('.trash-count');
    countBadges.forEach(badge => badge.style.display = 'none');
}

function openTrashModal() {
    const modal = document.getElementById('trash-modal');
    if (!modal) return;
    
    const itemsGrid = document.getElementById('trash-items-grid');
    itemsGrid.innerHTML = `
        <div class="trash-empty-state">
            <svg viewBox="0 0 24 24">
                <path d="M19,4H15.5L14.5,3H9.5L8.5,4H5V6H19M6,19A2,2 0 0,0 8,21H16A2,2 0 0,0 18,19V7H6V19Z"/>
            </svg>
            <p>Trash is empty</p>
        </div>
    `;
    
    modal.classList.add('active');
}

function closeTrashModal() {
    const modal = document.getElementById('trash-modal');
    if (modal) {
        modal.classList.remove('active');
    }
}

// ============================================
// DRAG AND DROP
// ============================================

function makeDraggable(element, itemKey) {
    element.draggable = true;
    element.classList.add('draggable');
    
    element.addEventListener('dragstart', function(e) {
        e.dataTransfer.setData('text/plain', itemKey);
        this.classList.add('dragging');
    });
    
    element.addEventListener('dragend', function(e) {
        this.classList.remove('dragging');
    });
}

function makeFolderDropTarget(element, folderId) {
    element.addEventListener('dragover', function(e) {
        e.preventDefault();
        this.classList.add('drag-over');
    });
    
    element.addEventListener('dragleave', function(e) {
        this.classList.remove('drag-over');
    });
    
    element.addEventListener('drop', async function(e) {
        e.preventDefault();
        e.stopPropagation();
        this.classList.remove('drag-over');
        
        const itemKey = e.dataTransfer.getData('text/plain');
        if (itemKey && itemKey !== folderId) {
            // Remove from current folder
            const currentFolder = getCurrentFolderId();
            if (currentFolder) {
                await removeItemFromFolder(currentFolder, itemKey);
            }
            
            // Remove from all folders
            const allFolders = await getAllFoldersFromDB();
            for (const folder of allFolders) {
                if (folder.items && folder.items.includes(itemKey)) {
                    await removeItemFromFolder(folder.id, itemKey);
                }
            }
            
            // Add to target folder
            await addItemToFolder(folderId, itemKey);
            
            // Refresh appropriate view
            const templatesScreen = document.getElementById('template-selection-screen');
            if (templatesScreen && templatesScreen.classList.contains('active')) {
                await loadTemplateCards();
            } else {
                await loadSavedDesigns();
            }
        }
    });
}

// ============================================
// LOAD SAVED DESIGNS (WITH INDEXEDDB)
// ============================================

async function loadSavedDesigns() {
    const grid = document.getElementById('saved-designs-grid');
    
    // Get all folders, designs, and exports from IndexedDB
    const allFolders = await getAllFoldersFromDB();
    const allDesigns = await EmailBriefingDB.getAllDesigns();
    const allExports = await EmailBriefingDB.getAllExports();
    
    // Filter for designs page folders
    const designFolders = allFolders.filter(f => !f.pageType || f.pageType === 'designs');
    
    // Filter items based on current folder
    const currentFolderId = getCurrentFolderId();
    let visibleFolders = [];
    let visibleDesigns = [];
    let visibleExports = [];
    
    if (currentFolderId) {
        const currentFolder = await getFolderFromDB(currentFolderId);
        if (currentFolder) {
            visibleFolders = designFolders.filter(f => currentFolder.items.includes(f.id));
            visibleDesigns = allDesigns.filter(d => currentFolder.items.includes(d.id));
            visibleExports = allExports.filter(e => currentFolder.items.includes(e.id));
        }
        
        // Also check parentPath for folders
        const subFolders = designFolders.filter(f => {
            const parentPath = f.parentPath || [];
            return parentPath.some(p => p.id === currentFolderId);
        });
        subFolders.forEach(f => {
            if (!visibleFolders.find(vf => vf.id === f.id)) {
                visibleFolders.push(f);
            }
        });
    } else {
        // Show root level items
        const allFolderItems = new Set();
        designFolders.forEach(f => {
            f.items.forEach(item => allFolderItems.add(item));
        });
        
        visibleFolders = designFolders.filter(f => {
            return !f.parentPath || f.parentPath.length === 0;
        });
        
        visibleDesigns = allDesigns.filter(d => !allFolderItems.has(d.id));
        visibleExports = allExports.filter(e => !allFolderItems.has(e.id));
    }
    
    // Display items
    if (visibleFolders.length === 0 && visibleDesigns.length === 0 && visibleExports.length === 0) {
        grid.innerHTML = '<p class="empty-state">No items here. Create a folder or email!</p>';
    } else {
        grid.innerHTML = '';
        
        // Render folders
        visibleFolders.forEach(folder => {
            const folderColor = folder.color || 'purple';
            const card = document.createElement('div');
            card.className = 'folder-card';
            card.innerHTML = `
                <div class="folder-card-content">
                    <img src="assets/images/folder-${folderColor}.png" class="folder-icon" alt="Folder">
                    <h3 class="folder-card-title">${folder.name}</h3>
                </div>
            `;
            
            card.addEventListener('click', function(e) {
                handleIconClick(e, card, folder.id, folder.name, 'folder');
            });
            
            card.addEventListener('dblclick', function(e) {
                handleIconDoubleClick(e, folder.id, 'folder');
            });
            
            card.addEventListener('contextmenu', function(e) {
                e.preventDefault();
                showFolderContextMenu(e, folder.id);
            });
            
            makeDraggable(card, folder.id);
            makeFolderDropTarget(card, folder.id);
            
            grid.appendChild(card);
        });
        
        // Render designs
        visibleDesigns.forEach(design => {
            const card = document.createElement('div');
            card.className = 'design-card';
            card.innerHTML = `
                <div class="design-card-content">
                    <img src="assets/images/document-icon.png" alt="${design.projectName}" class="document-icon">
                    <h3 class="design-card-title">${design.projectName}</h3>
                </div>
            `;
            
            card.addEventListener('click', function(e) {
                handleIconClick(e, card, design.id, design.projectName, 'design');
            });
            
            card.addEventListener('dblclick', function(e) {
                handleIconDoubleClick(e, design.id, 'design');
            });
            
            makeDraggable(card, design.id);
            
            grid.appendChild(card);
        });
        
        // Render exports
        visibleExports.forEach(exportItem => {
            const card = document.createElement('div');
            card.className = 'design-card export-card';
            card.innerHTML = `
                <div class="design-card-content">
                    <img src="assets/images/zip-icon.png" alt="${exportItem.projectName}" class="document-icon">
                    <h3 class="design-card-title">${exportItem.projectName}</h3>
                </div>
            `;
            
            card.addEventListener('click', function(e) {
                handleIconClick(e, card, exportItem.id, exportItem.projectName, 'export');
            });
            
            card.addEventListener('dblclick', function(e) {
                handleIconDoubleClick(e, exportItem.id, 'export');
            });
            
            makeDraggable(card, exportItem.id);
            
            grid.appendChild(card);
        });
    }
    
    updateBreadcrumb();
}

function showFolderContextMenu(event, folderId) {
    const existingMenu = document.querySelector('.folder-context-menu');
    if (existingMenu) existingMenu.remove();
    
    const menu = document.createElement('div');
    menu.className = 'folder-context-menu';
    menu.style.left = event.pageX + 'px';
    menu.style.top = event.pageY + 'px';
    
    menu.innerHTML = `
        <div class="context-menu-item" onclick="renameFolder('${folderId}')">Rename</div>
        <div class="context-menu-item danger" onclick="deleteFolder('${folderId}')">Delete</div>
    `;
    
    document.body.appendChild(menu);
    
    setTimeout(() => {
        document.addEventListener('click', function closeMenu() {
            menu.remove();
            document.removeEventListener('click', closeMenu);
        });
    }, 10);
}

// Initialize folder and trash functionality
document.addEventListener('DOMContentLoaded', function() {
    setupTrashBin();
    setupNewFolderButton();
    updateBreadcrumb();
});
